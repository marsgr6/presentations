<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Three-Dice Interaction Cube</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        #header {
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 20px;
            text-align: center;
        }
        h1 {
            font-size: 24px;
            margin-bottom: 10px;
        }
        .info {
            color: #666;
            font-size: 14px;
            margin: 5px 0;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-box {
            width: 16px;
            height: 16px;
        }
        #container {
            width: 100%;
            height: calc(100vh - 180px);
            cursor: move;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1 id="title">3D Three-Dice Interaction Cube - Loading...</h1>
        <div class="info">Blue die: faces [4,4,4,4,4,1] | Brown die: faces [3,3,3,3,3,6] | Black die: faces [2,2,2,5,5,5]</div>
        <div class="info"><strong>Click and drag to rotate • Each cube shows the winner for that combination</strong></div>
        <div class="legend">
            <div class="legend-item">
                <div class="color-box" style="background-color: #0000ff;"></div>
                <span id="blue-count">Blue: 0 (0%)</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #8B4513;"></div>
                <span id="brown-count">Brown: 0 (0%)</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #000000;"></div>
                <span id="black-count">Black: 0 (0%)</span>
            </div>
            <div class="legend-item">
                <div class="color-box" style="background-color: #888888;"></div>
                <span id="tie-count">Ties: 0 (0%)</span>
            </div>
        </div>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let cubes = [];
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let rotation = { x: 0.5, y: 0.5 };

        function init() {
            const container = document.getElementById('container');

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f0f0);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                container.clientWidth / container.clientHeight,
                0.1,
                1000
            );
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Grid
            const gridHelper = new THREE.GridHelper(12, 12, 0x888888, 0xcccccc);
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(8);
            scene.add(axesHelper);

            // Dice values
            const blueVals = [4, 4, 4, 4, 4, 1];
            const brownVals = [3, 3, 3, 3, 3, 6];
            const blackVals = [2, 2, 2, 5, 5, 5];

            // Count wins
            let blueWins = 0, brownWins = 0, blackWins = 0, ties = 0;

            // Create cubes
            for (let b = 0; b < 6; b++) {
                for (let br = 0; br < 6; br++) {
                    for (let bl = 0; bl < 6; bl++) {
                        const blueVal = blueVals[b];
                        const brownVal = brownVals[br];
                        const blackVal = blackVals[bl];

                        let color;
                        const maxVal = Math.max(blueVal, brownVal, blackVal);

                        if (blueVal === maxVal && brownVal === maxVal && blackVal === maxVal) {
                            color = 0x888888;
                            ties++;
                        } else if (blueVal === maxVal && brownVal === maxVal) {
                            color = 0x4444ff;
                            ties++;
                        } else if (blueVal === maxVal && blackVal === maxVal) {
                            color = 0x0088ff;
                            ties++;
                        } else if (brownVal === maxVal && blackVal === maxVal) {
                            color = 0x664422;
                            ties++;
                        } else if (blueVal === maxVal) {
                            color = 0x0000ff;
                            blueWins++;
                        } else if (brownVal === maxVal) {
                            color = 0x8B4513;
                            brownWins++;
                        } else {
                            color = 0x000000;
                            blackWins++;
                        }

                        const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                        const material = new THREE.MeshPhongMaterial({
                            color: color,
                            transparent: true,
                            opacity: 0.7
                        });
                        const cube = new THREE.Mesh(geometry, material);

                        cube.position.set(b - 2.5, br - 2.5, bl - 2.5);

                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(
                            edges,
                            new THREE.LineBasicMaterial({ color: 0x333333 })
                        );
                        cube.add(line);

                        scene.add(cube);
                        cubes.push(cube);
                    }
                }
            }

            // Update counts
            const total = 216;
            document.getElementById('title').textContent = 
                `3D Three-Dice Interaction Cube - Black wins: ${blackWins}/${total} (${((blackWins/total)*100).toFixed(1)}%)`;
            document.getElementById('blue-count').textContent = 
                `Blue: ${blueWins} (${((blueWins/total)*100).toFixed(1)}%)`;
            document.getElementById('brown-count').textContent = 
                `Brown: ${brownWins} (${((brownWins/total)*100).toFixed(1)}%)`;
            document.getElementById('black-count').textContent = 
                `Black: ${blackWins} (${((blackWins/total)*100).toFixed(1)}%)`;
            document.getElementById('tie-count').textContent = 
                `Ties: ${ties} (${((ties/total)*100).toFixed(1)}%)`;

            // Create text labels
            createTextLabel('Blue →', new THREE.Vector3(4, -4, -4), '#0000ff');
            createTextLabel('Brown →', new THREE.Vector3(-4, 4, -4), '#8B4513');
            createTextLabel('Black →', new THREE.Vector3(-4, -4, 4), '#000000');

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);

            // Mouse events
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('mouseleave', onMouseUp);

            // Window resize
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function createTextLabel(text, position, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 128;
            context.fillStyle = color;
            context.font = 'Bold 48px Arial';
            context.textAlign = 'center';
            context.fillText(text, 128, 80);

            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(2, 1, 1);
            scene.add(sprite);
        }

        function updateCameraPosition() {
            const radius = 14;
            const x = radius * Math.sin(rotation.y) * Math.cos(rotation.x);
            const y = radius * Math.sin(rotation.x);
            const z = radius * Math.cos(rotation.y) * Math.cos(rotation.x);

            camera.position.set(x, y, z);
            camera.lookAt(0, 0, 0);
        }

        function onMouseDown(e) {
            isDragging = true;
            previousMousePosition = { x: e.clientX, y: e.clientY };
        }

        function onMouseMove(e) {
            if (isDragging) {
                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                rotation.x += deltaY * 0.01;
                rotation.y += deltaX * 0.01;

                updateCameraPosition();

                previousMousePosition = { x: e.clientX, y: e.clientY };
            }
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onWindowResize() {
            const container = document.getElementById('container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>